type definite_canister_settings = 
 record {
   compute_allocation: nat;
   controllers: opt vec principal;
   freezing_threshold: nat;
   memory_allocation: nat;
 };
type canister_status = 
 record {
   cycles: nat;
   memory_size: nat;
   module_hash: opt vec nat8;
   settings: definite_canister_settings;
   status: variant {
             running;
             stopped;
             stopping;
           };
 };
type canister_id = principal;
type WithdrawResponse = 
 record {
   index: nat;
   timestamp: int;
   token_id: text;
   txn_type:
    variant {
      auction_bid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: text;
         token: TokenSpec;
       };
      burn: record {
              extensible: CandyShared;
              from: opt Account;
            };
      canister_managers_updated:
       record {
         extensible: CandyShared;
         managers: vec principal;
       };
      canister_network_updated:
       record {
         extensible: CandyShared;
         network: principal;
       };
      canister_owner_updated:
       record {
         extensible: CandyShared;
         owner: principal;
       };
      data:
       record {
         data_dapp: opt text;
         data_path: opt text;
         extensible: CandyShared;
         hash: opt vec nat8;
       };
      deposit_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         token: TokenSpec;
         trx_id: TransactionID;
       };
      escrow_deposit:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      escrow_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      extensible: CandyShared;
      mint:
       record {
         extensible: CandyShared;
         from: Account;
         sale: opt record {
                     amount: nat;
                     token: TokenSpec;
                   };
         to: Account;
       };
      owner_transfer:
       record {
         extensible: CandyShared;
         from: Account;
         to: Account;
       };
      royalty_paid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         receiver: Account;
         sale_id: opt text;
         seller: Account;
         tag: text;
         token: TokenSpec;
       };
      sale_ended:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: opt text;
         seller: Account;
         token: TokenSpec;
       };
      sale_opened:
       record {
         extensible: CandyShared;
         pricing: PricingConfig;
         sale_id: text;
       };
      sale_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
    };
 };
type WithdrawRequest = 
 variant {
   deposit: DepositWithdrawDescription;
   escrow: WithdrawDescription;
   reject: RejectDescription;
   sale: WithdrawDescription;
 };
type WithdrawDescription = 
 record {
   amount: nat;
   buyer: Account;
   seller: Account;
   token: TokenSpec;
   token_id: text;
   withdraw_to: Account;
 };
type Vec = 
 vec
  record {
    text;
    variant {
      BlobContent: vec nat8;
      BoolContent: bool;
      FloatContent: float64;
      Int16Content: int16;
      Int32Content: int32;
      Int64Content: int64;
      Int8Content: int8;
      IntContent: int;
      Nat16Content: nat16;
      Nat32Content: nat32;
      Nat64Content: nat64;
      Nat8Content: nat8;
      NatContent: nat;
      NestedContent: Vec;
      Principal: principal;
      TextContent: text;
    };
  };
type UpdateShared = 
 record {
   mode: UpdateModeShared;
   name: text;
 };
type UpdateRequestShared = 
 record {
   id: text;
   update: vec UpdateShared;
 };
type UpdateModeShared = 
 variant {
   Lock: CandyShared;
   Next: vec UpdateShared;
   Set: CandyShared;
 };
type UpdateCallsAggregatedData = vec nat64;
type TransactionRecord = 
 record {
   index: nat;
   timestamp: int;
   token_id: text;
   txn_type:
    variant {
      auction_bid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: text;
         token: TokenSpec;
       };
      burn: record {
              extensible: CandyShared;
              from: opt Account;
            };
      canister_managers_updated:
       record {
         extensible: CandyShared;
         managers: vec principal;
       };
      canister_network_updated:
       record {
         extensible: CandyShared;
         network: principal;
       };
      canister_owner_updated:
       record {
         extensible: CandyShared;
         owner: principal;
       };
      data:
       record {
         data_dapp: opt text;
         data_path: opt text;
         extensible: CandyShared;
         hash: opt vec nat8;
       };
      deposit_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         token: TokenSpec;
         trx_id: TransactionID;
       };
      escrow_deposit:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      escrow_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      extensible: CandyShared;
      mint:
       record {
         extensible: CandyShared;
         from: Account;
         sale: opt record {
                     amount: nat;
                     token: TokenSpec;
                   };
         to: Account;
       };
      owner_transfer:
       record {
         extensible: CandyShared;
         from: Account;
         to: Account;
       };
      royalty_paid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         receiver: Account;
         sale_id: opt text;
         seller: Account;
         tag: text;
         token: TokenSpec;
       };
      sale_ended:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: opt text;
         seller: Account;
         token: TokenSpec;
       };
      sale_opened:
       record {
         extensible: CandyShared;
         pricing: PricingConfig;
         sale_id: text;
       };
      sale_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
    };
 };
type TransactionID = 
 variant {
   extensible: CandyShared;
   "nat": nat;
   "text": text;
 };
type TokenSpec = 
 variant {
   extensible: CandyShared;
   ic: ICTokenSpec;
 };
type TokenMetadata = 
 record {
   approved_at: opt nat64;
   approved_by: opt principal;
   burned_at: opt nat64;
   burned_by: opt principal;
   is_burned: bool;
   minted_at: nat64;
   minted_by: principal;
   operator: opt principal;
   owner: opt principal;
   properties: vec record {
                     text;
                     GenericValue;
                   };
   token_identifier: nat;
   transferred_at: opt nat64;
   transferred_by: opt principal;
 };
type SubAccountInfo = 
 record {
   account: record {
              "principal": principal;
              sub_account: blob;
            };
   account_id: blob;
   account_id_text: text;
   "principal": principal;
 };
type StreamingStrategy = variant {
                           Callback:
                            record {
                              callback: func () -> ();
                              token: StreamingCallbackToken;
                            };};
type StreamingCallbackToken = 
 record {
   content_encoding: text;
   index: nat;
   key: text;
 };
type StreamingCallbackResponse = 
 record {
   body: blob;
   token: opt StreamingCallbackToken;
 };
type StorageMetricsResult = 
 variant {
   err: OrigynError;
   ok: StorageMetrics;
 };
type StorageMetrics = 
 record {
   allocated_storage: nat;
   allocations: vec AllocationRecordStable;
   available_space: nat;
   gateway: principal;
 };
type StateSize = 
 record {
   allocations: nat;
   buckets: nat;
   escrow_balances: nat;
   nft_ledgers: nat;
   nft_sales: nat;
   offers: nat;
   sales_balances: nat;
 };
type StakeRecord = 
 record {
   amount: nat;
   staker: Account;
   token_id: text;
 };
type StageLibraryResult = 
 variant {
   err: OrigynError;
   ok: StageLibraryResponse;
 };
type StageLibraryResponse = record {canister: principal;};
type StageChunkArg = 
 record {
   chunk: nat;
   content: blob;
   filedata: CandyShared;
   library_id: text;
   token_id: text;
 };
type StableSalesBalances = 
 vec record {
       Account;
       Account;
       text;
       EscrowRecord;
     };
type StableOffers = 
 vec record {
       Account;
       Account;
       int;
     };
type StableNftLedger = 
 vec record {
       text;
       TransactionRecord;
     };
type StableEscrowBalances = 
 vec record {
       Account;
       Account;
       text;
       EscrowRecord;
     };
type StableCollectionData = 
 record {
   active_bucket: opt principal;
   allocated_storage: nat;
   available_space: nat;
   logo: opt text;
   managers: vec principal;
   metadata: opt CandyShared;
   name: opt text;
   network: opt principal;
   owner: principal;
   symbol: opt text;
 };
type StableBucketData = 
 record {
   allocated_space: nat;
   allocations: vec record {
                      record {
                        text;
                        text;
                      };
                      int;
                    };
   available_space: nat;
   b_gateway: bool;
   date_added: int;
   "principal": principal;
   version: record {
              nat;
              nat;
              nat;
            };
 };
type ShareWalletRequest = 
 record {
   from: Account;
   to: Account;
   token_id: text;
 };
type SalesConfig = 
 record {
   broker_id: opt principal;
   escrow_receipt: opt EscrowReceipt;
   pricing: PricingConfig;
 };
type SaleStatusStable = 
 record {
   broker_id: opt principal;
   original_broker_id: opt principal;
   sale_id: text;
   sale_type:
    variant {
      auction: AuctionStateStable;
      dutch: DutchStateStable;
      nifty: NiftyStateStable;
    };
   token_id: text;
 };
type SaleInfoResult = 
 variant {
   err: OrigynError;
   ok: SaleInfoResponse;
 };
type SaleInfoResponse = 
 variant {
   active:
    record {
      count: nat;
      eof: bool;
      records: vec record {
                     text;
                     opt SaleStatusStable;
                   };
    };
   deposit_info: SubAccountInfo;
   history: record {
              count: nat;
              eof: bool;
              records: vec opt SaleStatusStable;
            };
   status: opt SaleStatusStable;
 };
type SaleInfoRequest = 
 variant {
   active: opt record {
                 nat;
                 nat;
               };
   deposit_info: opt Account;
   history: opt record {
                  nat;
                  nat;
                };
   status: text;
 };
type Result = 
 variant {
   err: OrigynError;
   ok: ManageSaleResponse;
 };
type RejectDescription = 
 record {
   buyer: Account;
   seller: Account;
   token: TokenSpec;
   token_id: text;
 };
type PropertyShared = 
 record {
   immutable: bool;
   name: text;
   value: CandyShared;
 };
type PricingConfig = 
 variant {
   auction: AuctionConfig;
   dutch: DutchConfig;
   extensible: CandyShared;
   flat: record {
           amount: nat;
           token: TokenSpec;
         };
   instant;
   nifty: NiftyConfig;
 };
type OwnerUpdateResult = 
 variant {
   err: OrigynError;
   ok: OwnerTransferResponse;
 };
type OwnerTransferResponse = 
 record {
   assets: vec CandyShared;
   transaction: TransactionRecord;
 };
type OwnerOfResponse = 
 variant {
   Err: NftError;
   Ok: opt principal;
 };
type OrigynTextResult = 
 variant {
   err: OrigynError;
   ok: text;
 };
type OrigynError = 
 record {
   error: Errors;
   flag_point: text;
   number: nat32;
   "text": text;
 };
type OrigynBoolResult = 
 variant {
   err: OrigynError;
   ok: bool;
 };
type NumericEntity = 
 record {
   avg: nat64;
   first: nat64;
   last: nat64;
   max: nat64;
   min: nat64;
 };
type NiftyStateStable = 
 record {
   allow_list: opt vec record {
                         principal;
                         bool;
                       };
   config: PricingConfig;
   current_broker_id: opt principal;
   end_date: int;
   min_bid: nat;
   status: variant {
             closed;
             not_started;
             open;
           };
   winner: opt Account;
 };
type NiftyConfig = 
 record {
   amount: nat;
   duration: opt int;
   expiration: opt int;
   fixed: bool;
   interestRatePerSecond: float64;
   lenderOffer: bool;
   token: TokenSpec;
 };
type Nft_Canister = 
 service {
   __advance_time: (int) -> (int);
   __set_time_mode: (variant {
                       standard;
                       test;
                     }) -> (bool);
   /// * Returns an array of tuples representing supported interfaces.
   ///     * @returns {Array<[Text, Text]>} - An array of tuples representing supported interfaces.
   __supports: () -> (vec record {
                            text;
                            text;
                          }) query;
   __version: () -> (text) query;
   /// * Get a backup chunk of the NFT data for a specified page.
   ///     *
   ///     * @param {number} page - The page to get the backup chunk for.
   ///     * @param {Record<string,unknown>} msg - The request message.
   ///     * @returns {Promise<{ eof: Types.NFTBackupChunk, data: Types.NFTBackupChunk }>} The backup chunk, which can be either the data or the end-of-file (EOF) marker.
   back_up: (nat) ->
    (variant {
       data: NFTBackupChunk;
       eof: NFTBackupChunk;
     }) query;
   /// * Returns the balance of a Dip721 token for a given user.
   ///     * @param {Object} request - Therequest.
   ///     * @returns {Types.EXTBalanceResult} -  Dip721 balance for the user.
   balance: (EXTBalanceRequest) -> (EXTBalanceResult) query;
   /// * Provides the external balance of a given token holder.
   ///     * @param {Object} request - The request object containing the parameters for the balance request.
   balanceEXT: (EXTBalanceRequest) -> (EXTBalanceResult) query;
   /// * Retrieves the balance for a batch of accounts in the Origyn server.
   ///     * @param {Types.Account[]} requests - The accounts to retrieve the balances for.
   ///     * @returns {Promise<Types.BalanceResult[]>} The balance responses or errors for the given accounts.
   balance_of_batch_nft_origyn: (vec Account) -> (vec BalanceResult) query;
   /// * Retrieves the balance for a given account in the Origyn NFT.
   ///     * @param {Types.Account} account - The account to retrieve the balance for.
   ///     * @returns {Promise<Types.BalanceResult>} The balance response or an error.
   balance_of_nft_origyn: (Account) -> (BalanceResult) query;
   /// * Allows secure access to the balances of a batch of accounts in the Origyn server.
   ///     * @param {Types.Account[]} requests - The accounts to retrieve the balances for.
   ///     * @returns {Promise<Types.BalanceResult[]>} The balance responses or errors for the given accounts.
   balance_of_secure_batch_nft_origyn: (vec Account) -> (vec BalanceResult);
   /// * Allows secure access to the balance of an account in the Origyn server.
   ///     * @param {Types.Account} account - The account to retrieve the balance for.
   ///     * @returns {Promise<Types.BalanceResult>} The balance response or an error.
   balance_of_secure_nft_origyn: (Account) -> (BalanceResult);
   /// * Supports EXT Bearer legacy
   ///     * @param {Types.EXTTokenIdentifier} tokenIdentifier - The token identifier.
   ///     * @returns {Promise<Types.EXTBearerResult>} The bearer account identifier.
   bearer: (EXTTokenIdentifier) -> (EXTBearerResult) query;
   /// * Supports EXT Bearer
   ///     * @param {Types.EXTTokenIdentifier} tokenIdentifier - The token identifier.
   ///     * @returns {Promise<Types.EXTBearerResult>} The bearer account identifier.
   bearerEXT: (EXTTokenIdentifier) -> (EXTBearerResult) query;
   /// * Provides access to searching a large number of NFT bearers at once in the Origyn server.
   ///     * @param {Array<Text>} tokens - The array of token IDs of the NFTs to retrieve the owners for.
   ///     * @returns {Promise<Array<Types.BearerResult>>} An array of results where each element corresponds to the account that owns the corresponding token in the input array or an error.
   bearer_batch_nft_origyn: (vec text) -> (vec BearerResult) query;
   /// * Provides secure access to searching a large number of bearers at one time.
   ///     * @param {Array<Text>} tokens - An array of token IDs to search for.
   ///     * @returns {Array<Promise<Types.BearerResult>>} - An array of promises, each resolving to a Result object containing either the owner account or an OrigynError.
   bearer_batch_secure_nft_origyn: (vec text) -> (vec BearerResult);
   /// * Retrieves the account that currently owns an NFT with the given token ID in the Origyn server.
   ///     * @param {Text} token_id - The ID of the NFT to retrieve the owner for.
   ///     * @returns {Promise<Types.BearerResult>} The account that owns the NFT or an error.
   bearer_nft_origyn: (text) -> (BearerResult) query;
   /// * Allows secure access to the account that currently owns an NFT with the given token ID in the Origyn server.
   ///     * @param {Text} token_id - The ID of the NFT to retrieve the owner for.
   ///     * @returns {Promise<Types.BearerResult>} The account that owns the NFT or an error.
   bearer_secure_nft_origyn: (text) -> (BearerResult);
   /// * Returns the status of the gateway canister
   ///     * @param request - The canister ID of the gateway
   ///     * @returns The status of the gateway canister
   canister_status: (record {canister_id: canister_id;}) -> (canister_status);
   /// * Pulls a chunk of an NFT library.
   ///     * 
   ///     * @param {Types.ChunkRequest} request - The chunk request object.
   ///     * @returns {async Types.ChunkResult} - The chunk content or an error.
   chunk_nft_origyn: (ChunkRequest) -> (ChunkResult) query;
   /// * Secure access to chunks of an NFT library.
   ///     * 
   ///     * @param {Types.ChunkRequest} request - The chunk request object.
   ///     * @returns {async Types.ChunkResult} - The chunk content or an error.
   chunk_secure_nft_origyn: (ChunkRequest) -> (ChunkResult);
   /// * Collects canister metrics.
   ///     * @returns {null}
   collectCanisterMetrics: () -> () query;
   /// * Returns information about the collection.
   ///     * @param {Array} fields - An optional array of tuples representing the fields to be returned and the range of items to be returned.
   ///     * @param {Text} fields[0] - The name of the field to be returned.
   ///     * @param {Nat} fields[1] - Optional. The index of the first item to be returned.
   ///     * @param {Nat} fields[2] - Optional. The number of items to be returned.
   ///     * @returns {Promise<Types.CollectionResult>} - A promise that resolves to a Result object containing the CollectionInfo or an error message.
   collection_nft_origyn: (opt vec record {
                                     text;
                                     opt nat;
                                     opt nat;
                                   }) -> (CollectionResult) query;
   /// * Secure access to collection information
   ///     *
   ///     * @param {Record} msg - A record containing the caller of the function
   ///     * @param {Array} fields - An optional array of tuples representing the fields to be returned and the range of items to be returned.
   ///     * @param {Text} fields[0] - The name of the field to be returned.
   ///     * @param {Nat} fields[1] - Optional. The index of the first item to be returned.
   ///     * @param {Nat} fields[2] - Optional. The number of items to be returned.
   ///     * @returns {Promise<Types.CollectionResult>} - A promise that resolves to a Result object containing the CollectionInfo or an error message.
   collection_secure_nft_origyn: (opt vec record {
                                            text;
                                            opt nat;
                                            opt nat;
                                          }) -> (CollectionResult);
   /// * Allows batch operations to update collection properties such as managers, owners, and the network
   ///     * @param {Array<Types.ManageCollectionCommand>} requests - The array of requests for batch processing
   ///     * @returns {Array<Types.OrigynBoolResult>} - The results of the batch processing
   ///     * @throws Throws an error if the canister is in maintenance mode or if the caller is not a canister owner or network
   collection_update_batch_nft_origyn: (vec ManageCollectionCommand) ->
    (vec OrigynBoolResult);
   /// * Get sale information for multiple sales in a secure manner.
   ///     * @param {Array<Types.SaleInfoRequest>} requests - An array of sale info requests.
   ///     * @returns {Array<Types.SaleInfoResult>} An array of sale info responses.
   ///     * @throws {Error} Throws an error if the canister is in maintenance mode.
   collection_update_nft_origyn: (ManageCollectionCommand) ->
    (OrigynBoolResult);
   /// * Reports the cycles available for this canister
   ///     * @returns The available cycles
   cycles: () -> (nat) query;
   /// * Returns the balance of a Dip721 token for a given user.
   ///     * @param {Object} request - Therequest.
   ///     * @returns {Nat} -  Dip721 balance for the user.
   dip721_balance_of: (principal) -> (nat) query;
   /// * Returns the list of custodians for the DIP721 collection.
   ///     * @returns {[Principal]} The list of custodians for the DIP721 collection.
   dip721_custodians: () -> (vec principal) query;
   /// * Determines if a given operator is approved for all tokens owned by a given owner.
   ///     * @param {Principal} owner - The principal of the owner of the tokens.
   ///     * @param {Principal} operator - The principal of the operator to be checked.
   ///     * @returns {DIP721.Result_1} A result indicating whether the operator is approved for all tokens.
   dip721_is_approved_for_all: (principal, principal) ->
    (DIP721BoolResult) query;
   /// * Returns the logo of the DIP721 collection.
   ///     * @returns {?Text} The logo of the DIP721 collection.
   dip721_logo: () -> (opt text) query;
   /// * Returns the metadata of the DIP721 collection.
   ///     * @returns {DIP721.Metadata} The metadata of the DIP721 collection.
   dip721_metadata: () -> (DIP721Metadata) query;
   /// * Returns the name of the DIP721 collection.
   ///     * @returns {?Text} The name of the DIP721 collection.
   dip721_name: () -> (opt text) query;
   /// * Returns the token identifiers of all tokens for which a given principal is the operator.
   ///     * @param {Principal} operator - The principal of the operator whose token identifiers will be returned.
   ///     * @returns {DIP721.Metadata_1} The token identifiers of all tokens for which the specified principal is the operator.
   dip721_operator_token_identifiers: (principal) ->
    (DIP721TokensListMetadata) query;
   /// * Returns the metadata of all tokens for which a given principal is the operator.
   ///     * @param {Principal} operator - The principal of the operator whose tokens' metadata will be returned.
   ///     * @returns {DIP721.Metadata_2} The metadata of all tokens for which the specified principal is the operator.
   dip721_operator_token_metadata: (principal) ->
    (DIP721TokensMetadata) query;
   /// * Returns the owner of the DIP721 token indicated by tokenAsNat.
   ///     * @param {Nat} tokenAsNat - The token identifier as a Nat.
   ///     * @returns {async DIP721.OwnerOfResponse} The owner of the DIP721 token.
   dip721_owner_of: (nat) -> (OwnerOfResponse) query;
   /// * Returns the token identifiers of all tokens owned by a given owner.
   ///     * @param {Principal} owner - The principal of the owner whose token identifiers will be returned.
   ///     * @returns {DIP721.Metadata_1} The token identifiers of all tokens owned by the specified owner.
   dip721_owner_token_identifiers: (principal) ->
    (DIP721TokensListMetadata) query;
   /// * Returns the metadata of all tokens owned by a given owner.
   ///     * @param {Principal} owner - The principal of the owner whose tokens' metadata will be returned.
   ///     * @returns {DIP721.Metadata_2} The metadata of all tokens owned by the specified owner.
   dip721_owner_token_metadata: (principal) -> (DIP721TokensMetadata) query;
   /// * Returns the statistics of the DIP721 collection.
   ///     * @returns {DIP721.Stats} The statistics of the DIP721 collection.
   dip721_stats: () -> (DIP721Stats) query;
   /// * Returns the list of supported interfaces for the DIP721 collection.
   ///     * @returns {[DIP721.SupportedInterface]} The list of supported interfaces for the DIP721 collection.
   dip721_supported_interfaces: () -> (vec DIP721SupportedInterface) query;
   /// * Returns the symbol of the DIP721 collection.
   ///     * @returns {?Text} The symbol of the DIP721 collection.
   dip721_symbol: () -> (opt text) query;
   /// * Returns the metadata of a given token.
   ///     * @param {Nat} token_id - The id of the token whose metadata will be returned.
   ///     * @returns {DIP721.Metadata_3} The metadata of the specified token.
   dip721_token_metadata: (nat) -> (DIP721TokenMetadata) query;
   /// * Returns the total supply of the DIP721 collection.
   ///     * @returns {Nat} The total supply of the DIP721 collection.
   dip721_total_supply: () -> (nat) query;
   /// * Returns the total number of transactions of the DIP721 collection.
   ///     * @returns {Nat} The total number of transactions of the DIP721 collection.
   dip721_total_transactions: () -> (nat) query;
   /// * Transfer a DIP-721 token to a specified principal. Escrow must exist.
   ///     * @param {Principal} to - The principal to transfer the token to.
   ///     * @param {Nat} tokenAsNat - The token identifier as a natural number.
   ///     * @returns {DIP721.Result} A result indicating whether the transfer was successful or not.
   ///     * @throws {Error} If the canister is in maintenance mode.
   dip721_transfer: (principal, nat) -> (DIP721NatResult);
   /// * Performs a transfer of a DIP-721 token from one account to another, provided that the `from` account has previously granted permission to the `caller` account to perform this transfer.
   ///     * 
   ///     * @param {Principal} from - The account that currently owns the token being transferred.
   ///     * @param {Principal} to - The account to which the token is being transferred.
   ///     * @param {Nat} tokenAsNat - The token ID being transferred.
   ///     * 
   ///     * @returns {async DIP721.Result} - The result of the transfer operation, which could be an error or success.
   ///     * 
   ///     * @throws {Error} - If the canister is currently in maintenance mode.
   dip721_transfer_from: (principal, principal, nat) -> (DIP721NatResult);
   /// * Returns canister log.
   ///     * @param {?Canistergeek.CanisterLogRequest} request - A request object for getting canister log.
   ///     * @returns {?Canistergeek.CanisterLogResponse} - Canister log or null if not found.
   getCanisterLog: (opt CanisterLogRequest) ->
    (opt CanisterLogResponse) query;
   /// * Returns canister metrics.
   ///     * @param {Canistergeek.GetMetricsParameters} parameters - Parameters for getting canister metrics.
   ///     * @returns {?Canistergeek.CanisterMetrics} - Canister metrics or null if not found.
   getCanisterMetrics: (GetMetricsParameters) -> (opt CanisterMetrics) query;
   /// * Retrieves the EXT token identifier for a given token ID.
   ///     * @param {Text} token_id - The ID of the token to retrieve the EXT token identifier for.
   ///     * @returns {Promise<Text>} The EXT token identifier for the given token ID.
   getEXTTokenIdentifier: (text) -> (text) query;
   /// * Retrieves the HTTP access key associated with the caller's identity, if it exists.
   ///     * @returns {Types.OrigynTextResult} A `Result` object containing the access key, or an error message if it was not found.
   get_access_key: () -> (OrigynTextResult) query;
   get_halt: () -> (bool) query;
   /// * Converts a Nat to a token_id for Nat.
   ///     *
   ///     * @param {Nat} tokenAsNat - The Nat to be converted.
   ///     * @returns {Text} The token_id corresponding to the given Nat.
   get_nat_as_token_id_origyn: (nat) -> (text) query;
   /// * Converts a token ID to a Nat for use in dip721.
   ///     * @param {Text} token_id - The token ID to be converted.
   ///     * @returns {Nat} The converted token ID as a Nat.
   ///     * @throws Will throw an error if the canister is in maintenance mode.
   get_token_id_as_nat_origyn: (text) -> (nat) query;
   governance_batch_nft_origyn: (vec GovernanceRequest) ->
    (vec GovernanceResult);
   /// * Used by the network to perform governance actions that have been voted on by OGY token holders
   ///     * For non OGY NFTs you will need to call this function from the principal set as your 'network'
   ///     *
   ///     * @param {Types.GovernanceRequest} request - The governance request object
   ///     * @param {Principal} msg.caller - The principal of the caller
   ///     *
   ///     * @returns {async Types.GovernanceResult} The result of the governance operation
   ///     *
   ///     * @throws {Error} Throws an error if the canister is in maintenance mode
   governance_nft_origyn: (GovernanceRequest) -> (GovernanceResult);
   /// * Provides access to searching a large number of histories.
   ///     * @param {Array.<{token_id: string, start: ?number, end: ?number}>} tokens - An array of objects representing the token IDs and range of transaction records to be returned.
   ///     * @param {string} tokens.token_id - The ID of the token.
   ///     * @param {number} [tokens.start] - Optional. The index of the first transaction record to be returned.
   ///     * @param {number} [tokens.end] - Optional. The index of the last transaction record to be returned.
   ///     * @returns {Array.<Promise<Result.Result<Array.<Types.TransactionRecord>, Types.OrigynError>>>} - An array of promises that resolve to Result objects containing the transaction records or an error message for each token ID.
   history_batch_nft_origyn: (vec record {
                                    text;
                                    opt nat;
                                    opt nat;
                                  }) -> (vec HistoryResult) query;
   /// * Provides secure access to history batch.
   ///     * @param {Array} tokens - An array of tuples representing the tokens and their history.
   ///     * @param {Text} tokens[n][0] - The token id to retrieve history from.
   ///     * @param {Nat} tokens[n][1] - Optional. The index of the first item to be returned.
   ///     * @param {Nat} tokens[n][2] - Optional. The number of items to be returned.
   ///     * @returns {Promise<Array<Types.HistoryResult>>} - A promise that resolves to an array of Result objects containing the TransactionRecords or an error message.
   history_batch_secure_nft_origyn: (vec record {
                                           text;
                                           opt nat;
                                           opt nat;
                                         }) -> (vec HistoryResult);
   /// * Allows users to see token information - ledger and history
   ///     * @param {Text} token_id - The ID of the token to retrieve information for.
   ///     * @param {Nat} [start] - Optional. The starting index of the transaction history to retrieve.
   ///     * @param {Nat} [end] - Optional. The ending index of the transaction history to retrieve.
   ///     * @returns {Promise<Result.Result<Array<Types.TransactionRecord>, Types.OrigynError>>} - A promise that resolves to a Result object containing the array of transaction records or an error message.
   history_nft_origyn: (text, opt nat, opt nat) -> (HistoryResult) query;
   /// * Secure access to token history
   ///     * @param {Record<string, *>} msg - The request message.
   ///     * @param {Text} msg.caller - The principal ID of the caller.
   ///     * @param {Text} token_id - The ID of the token.
   ///     * @param {Nat} [start] - The starting index (inclusive) of the token history to return.
   ///     * @param {Nat} [end] - The ending index (inclusive) of the token history to return.
   ///     * @returns {Promise<Result.Result<Array<Types.TransactionRecord>, Types.OrigynError>>} - A promise that resolves to a Result object containing an array of TransactionRecord objects or an error message.
   history_secure_nft_origyn: (text, opt nat, opt nat) -> (HistoryResult);
   /// * Generates an HTTP access key for a user, and stores it in the canister's state.
   ///     * @returns {Types.OrigynTextResult} A `Result` object containing the generated access key, or an error message.
   http_access_key: () -> (OrigynTextResult);
   /// * Handles an HTTP request.
   ///     * @param {Types.HttpRequest} rawReq - The HTTP request to handle.
   ///     * @returns {http.HTTPResponse} An `HTTPResponse` object containing the response data for the request.
   http_request: (HttpRequest) -> (HTTPResponse) query;
   /// * Handles streaming requests
   ///     * @param tk - The streaming callback token
   ///     * @returns The streaming callback response
   http_request_streaming_callback: (StreamingCallbackToken) ->
    (StreamingCallbackResponse) query;
   /// * Allows the owner to manage the storage on their NFT
   ///     *
   ///     * @param {Types.ManageStorageRequest} request - the request for the management of storage
   ///     * @returns {async Types.ManageStorageResult} Returns a result indicating whether the storage management was successful or an error occurred
   ///     * @throws Throws an error if the canister is in maintenance mode or if the caller is not the owner or network
   manage_storage_nft_origyn: (ManageStorageRequest) -> (ManageStorageResult);
   /// * Start a large number of sales/market transfers. Currently limited to owners, managers, or the network
   ///     * @param {Array<Types.MarketTransferRequest>} request - An array of market transfer requests
   ///     * @returns {Array<Types.MarketTransferResult>} - An array of results for each market transfer request
   market_transfer_batch_nft_origyn: (vec MarketTransferRequest) ->
    (vec MarketTransferResult);
   /// * Allows the market based transfer of NFTs
   ///     * @param {Object} request - The market transfer request object.
   ///     * @param {Text} request.token_id - The token ID.
   ///     * @param {Types.SalesConfig} request.sales_config - The sales configuration object.
   ///     * @param {Principal} request.seller - The seller's principal ID.
   ///     * @param {Principal} request.buyer - The buyer's principal ID.
   ///     * @returns {async Types.MarketTransferResult} A Result object that either contains the MarketTransferRequestReponse or an OrigynError.
   market_transfer_nft_origyn: (MarketTransferRequest) ->
    (MarketTransferResult);
   /// * Returns the metadata of the DIP721 collection.
   ///     * @returns {DIP721.Metadata} The metadata of the DIP721 collection.
   metadata: () -> (DIP721Metadata) query;
   /// * Returns metadata for ext
   ///     * @param token - The token identifier
   ///     * @returns The metadata for ext
   metadataExt: (EXTTokenIdentifier) -> (EXTMetadataResult) query;
   /// * Allows minting of multiple items
   ///     * @param {Array.<[Text, Types.Account]>} tokens - An array of tuples, each containing the token ID and the account of the new owner for each item to be minted.
   ///     * @returns {Array.<Types.OrigynTextResult>} An array of results for each item in the batch, indicating success or failure with a resulting error message if applicable.
   mint_batch_nft_origyn: (vec record {
                                 text;
                                 Account;
                               }) -> (vec OrigynTextResult);
   /// * Mints a new NFT token and assigns it to the specified owner.
   ///     * 
   ///     * @param {Text} token_id - The ID of the new NFT token.
   ///     * @param {Types.Account} new_owner - The new owner of the NFT token.
   ///     * @param {msg} msg - The message context.
   ///     * @returns {Types.OrigynTextResult} A Result indicating success or failure, with the new token ID on success.
   ///     * @throws {Error} Throws an error if the canister is in maintenance mode.
   mint_nft_origyn: (text, Account) -> (OrigynTextResult);
   /// * A streaming callback based on NFTs. Returns {[], null} if the token can not be found.
   ///     * Expects a key of the following pattern: "nft/{key}".
   ///     * @param tk - The streaming callback token
   ///     * @returns The streaming callback response
   nftStreamingCallback: (StreamingCallbackToken) ->
    (StreamingCallbackResponse) query;
   /// * Batch access to nft metadata
   ///     * @param {Text[]} token_ids - An array of NFT ids to retrieve metadata for
   ///     * @returns {async [Types.NFTInfoResult]} - An array of NFT metadata or errors for each provided token id
   nft_batch_origyn: (vec text) -> (vec NFTInfoResult) query;
   /// * Secure batch access to nft metadata
   ///     * @param {Text[]} token_ids - An array of NFT ids to retrieve metadata for
   ///     * @returns {async [Types.NFTInfoResult]} - An array of NFT metadata or errors for each provided token id
   nft_batch_secure_origyn: (vec text) -> (vec NFTInfoResult);
   /// * Returns metadata about an NFT
   ///     * @param {Text} token_id - The id of the NFT to retrieve metadata for
   ///     * @returns {async Types.NFTInfoResult} - The NFT metadata, or an error if it does not exist or could not be retrieved
   nft_origyn: (text) -> (NFTInfoResult) query;
   /// * Secure access to nft_origyn
   ///     * @param {Text} token_id - The id of the NFT to retrieve metadata for
   ///     * @returns {async Types.NFTInfoResult} - The NFT metadata, or an error if it does not exist or could not be retrieved
   nft_secure_origyn: (text) -> (NFTInfoResult);
   /// * Returns the metadata of all tokens for which a given principal is the operator.
   ///     * @param {Principal} operator - The principal of the operator whose tokens' metadata will be returned.
   ///     * @returns {DIP721.Metadata_2} The metadata of all tokens for which the specified principal is the operator.
   operaterTokenMetadata: (principal) -> (DIP721TokensMetadata) query;
   /// * For dip721 legacy
   ///     * @param {Nat} tokenAsNat - The token ID as a Nat.
   ///     * @returns {Promise<DIP721.OwnerOfResponse>} The owner of the DIP721 token.
   ownerOf: (nat) -> (OwnerOfResponse) query;
   /// * Returns the metadata of all tokens owned by a given owner.
   ///     * @param {Principal} owner - The principal of the owner whose tokens' metadata will be returned.
   ///     * @returns {DIP721.Metadata_2} The metadata of all tokens owned by the specified owner.
   ownerTokenMetadata: (principal) -> (DIP721TokensMetadata) query;
   /// * Allows batch operations for managing NFT sales, including ending a sale, opening a sale, depositing an escrow, refreshing offers, bidding in an auction, withdrawing funds from an escrow or sale.
   ///     * @param {Array<Types.ManageSaleRequest>} requests - An array of ManageSaleRequest objects, each representing a different sale management operation.
   ///     * @returns {Array<Types.ManageSaleResult>} - An array of Result objects, each representing the result of the corresponding operation in the input array.
   ///     * @throws {Error} If the canister is in maintenance mode or the caller is not an owner, manager, or network.
   sale_batch_nft_origyn: (vec ManageSaleRequest) -> (vec ManageSaleResult);
   /// * Retrieves sale information for a batch of NFTs.
   ///     * @param {Types.SaleInfoRequest[]} requests - The array of request objects containing information about the type of sale information to retrieve.
   ///     * @param {Principal} msg.caller - The caller principal.
   ///     * @returns {Promise<Types.SaleInfoResult[]>} - An array of results of the operation, each containing either the sale information or an error.
   sale_info_batch_nft_origyn: (vec SaleInfoRequest) ->
    (vec SaleInfoResult) query;
   sale_info_batch_secure_nft_origyn: (vec SaleInfoRequest) ->
    (vec SaleInfoResult);
   /// * Retrieves sale information for a single NFT in a secure manner.
   ///     * @param {Types.SaleInfoRequest} request - The request object containing information about the type of sale information to retrieve.
   ///     * @param {Principal} msg.caller - The caller principal.
   ///     * @returns {Promise<Types.SaleInfoResult>} - The result of the operation, containing either the sale information or an error.
   sale_info_nft_origyn: (SaleInfoRequest) -> (SaleInfoResult) query;
   /// * Retrieves sale information for a single NFT in a secure manner.
   ///     * @param {Types.SaleInfoRequest} request - The request object containing information about the type of sale information to retrieve.
   ///     * @param {Principal} msg.caller - The caller principal.
   ///     * @returns {Promise<Types.SaleInfoResult>} - The result of the operation, containing either the sale information or an error.
   ///     * @throws {Error} - Throws an error if the canister is in maintenance mode.
   sale_info_secure_nft_origyn: (SaleInfoRequest) -> (SaleInfoResult);
   /// * Allows a user to manage a NFT sale, including ending a sale, opening a sale, depositing an escrow, refreshing offers, bidding in an auction, withdrawing funds from an escrow or sale.
   ///     * @param {Types.ManageSaleRequest} request - The request object containing the action to perform and relevant parameters.
   ///     * @returns {Promise<Types.ManageSaleResult>} - Returns a promise that resolves to a result object containing a response object or an Origyn error.
   sale_nft_origyn: (ManageSaleRequest) -> (ManageSaleResult);
   set_data_harvester: (nat) -> ();
   set_halt: (bool) -> ();
   /// * Allows an owner to transfer a NFT from one of their wallets to another.
   ///     * Warning: this feature will be updated in the future to give both wallets access to the NFT
   ///     * for some set period of time including access to assets beyond just the NFT ownership. It should not
   ///     * be used with a wallet that you do not 100% trust to not take the NFT back. It is meant for
   ///     * internal accounting only. Use market_transfer_nft_origyn instead
   ///     *
   ///     * @param {Types.ShareWalletRequest} request - The request to share the NFT wallet.
   ///     * @param {msg} msg - The message object that contains the caller of the function.
   ///     * @returns {async Types.OwnerUpdateResult} - The response containing the status of the operation.
   share_wallet_nft_origyn: (ShareWalletRequest) -> (OwnerUpdateResult);
   /// * Stages multiple NFTs for origyn verification.
   ///     *
   ///     * @param {Array<Record{metadata: CandyTypes.CandyShared}>} request - The metadata for the NFTs being staged.
   ///     * @returns {async Array<Types.OrigynTextResult>} - An array containing the results of the staging operations.
   stage_batch_nft_origyn: (vec record {metadata: CandyShared;}) ->
    (vec OrigynTextResult);
   /// * Stages a library NFT chunk for Origyn.
   ///     * 
   ///     * @param {Types.StageChunkArg} chunk - The chunk to stage.
   ///     * @returns {async Types.StageLibraryResult} The result of the staging operation.
   ///     * @throws Will throw an error if the canister is in maintenance mode.
   stage_library_batch_nft_origyn: (vec StageChunkArg) ->
    (vec StageLibraryResult);
   stage_library_nft_origyn: (StageChunkArg) -> (StageLibraryResult);
   /// * Stages an NFT for origyn verification.
   ///     *
   ///     * @param {Record{metadata: CandyTypes.CandyShared}} request - The metadata for the NFT being staged.
   ///     * @returns {async Types.OrigynTextResult} - The result of the staging operation.
   stage_nft_origyn: (record {metadata: CandyShared;}) -> (OrigynTextResult);
   /// * Get the size of the state in terms of the number of elements in various maps.
   ///     *
   ///     * @param {Record<string,unknown>} msg - The request message.
   ///     * @returns {Promise<Types.StateSize>} The size of the state.
   state_size: () -> (StateSize) query;
   /// * Returns storage metrics for this server
   ///     * @returns The storage metrics for this server
   storage_info_nft_origyn: () -> (StorageMetricsResult) query;
   /// * Secure access to storage metrics for this server
   ///     * @returns The storage metrics for this server
   storage_info_secure_nft_origyn: () -> (StorageMetricsResult);
   /// * Queries the tokens for a given request.
   ///     * @param {Text} request - The request for which to retrieve the tokens.
   ///     * @returns {Promise<Result.Result<[Types.EXTTokensResult], Types.EXTCommonError>>} The tokens result or an error.
   tokens_ext: (text) -> (EXTTokensResult) query;
   /// * Performs a legacy EXT transfer, which requires a valid escrow.
   ///     * 
   ///     * @param {object} request - The transfer request object.
   ///     * @param {Nat} request.amount - The amount of the transfer.
   ///     * @param {Text} request.token_id - The ID of the token to transfer.
   ///     * @param {Principal} request.to - The principal to transfer the token to.
   ///     * @param {Principal} request.from - The principal initiating the transfer.
   ///     * @param {Nat} request.fee - The fee for the transfer.
   ///     * 
   ///     * @returns {Promise<Types.EXTTransferResponse>} A promise that resolves to an EXT transfer response object.
   ///     * @throws Will throw an error if the canister is in maintenance mode.
   transfer: (EXTTransferRequest) -> (EXTTransferResponse);
   /// * Transfers a Dip721 token to another account.
   ///     * 
   ///     * @param {Principal} to - The principal of the account to transfer the token to.
   ///     * @param {Nat} tokenAsNat - The ID of the token to transfer.
   ///     * @returns {Promise<DIP721.Result>} - The result of the transfer operation.
   ///     * @throws {Error} - If the canister is in maintenance mode.
   transferDip721: (principal, nat) -> (DIP721NatResult);
   /// * Transfer an external token from one account to another, must have a valid escrow.
   ///     * @param request - The transfer request object containing the token and recipient details
   ///     * @returns The transfer response object containing the transaction status and details
   ///     * @throws {Error} Throws an error if the canister is in maintenance mode
   transferEXT: (EXTTransferRequest) -> (EXTTransferResponse);
   /// * Performs a Dip721 transferFrom of a token from one wallet to another.
   ///     * @param {Principal} from - The wallet address to transfer from.
   ///     * @param {Principal} to - The wallet address to transfer to.
   ///     * @param {Nat} tokenAsNat - The token to be transferred represented as a natural number.
   ///     * @returns {Promise<DIP721.Result>} - Result of the transfer operation.
   ///     * @throws {Error} - Throws an error if the canister is in maintenance mode.
   transferFrom: (principal, principal, nat) -> (DIP721NatResult);
   /// * Dip721 transferFrom - must have a valid escrow
   ///     *
   ///     * @param {Principal} from - The principal to transfer the token from
   ///     * @param {Principal} to - The principal to transfer the token to
   ///     * @param {Nat} tokenAsNat - The token to be transferred
   ///     *
   ///     * @return {DIP721.Result} A result object indicating success or failure
   ///     *
   ///     * @throws {Error} Throws an error if the canister is in maintenance mode
   transferFromDip721: (principal, principal, nat) -> (DIP721NatResult);
   /// * Updates the entire API nodes with the given NFT update request data.
   ///     *
   ///     * @param {Types.NFTUpdateRequest} request - The request data for the NFT update.
   ///     * @returns {Promise<Types.NFTUpdateResult>} - A promise that resolves to a Result object containing either the NFT update response or an OrigynError.
   ///     * @throws {Error} - Throws an error if the canister is in maintenance mode.
   update_app_nft_origyn: (NFTUpdateRequest) -> (NFTUpdateResult);
   /// * Lets the NFT accept cycles.
   ///     * @returns {Nat} - The amount of cycles accepted.
   wallet_receive: () -> (nat);
   /// * Returns the caller's Principal ID
   ///     * @returns The caller's Principal ID
   whoami: () -> (principal) query;
 };
type NftError = 
 variant {
   ExistedNFT;
   OperatorNotFound;
   Other: text;
   OwnerNotFound;
   SelfApprove;
   SelfTransfer;
   TokenNotFound;
   TxNotFound;
   UnauthorizedOperator;
   UnauthorizedOwner;
 };
type Nanos = nat64;
type NFTUpdateResult = 
 variant {
   err: OrigynError;
   ok: NFTUpdateResponse;
 };
type NFTUpdateResponse = bool;
type NFTUpdateRequest = 
 variant {
   replace: record {
              data: CandyShared;
              token_id: text;
            };
   update: record {
             app_id: text;
             token_id: text;
             update: UpdateRequestShared;
           };
 };
type NFTInfoStable = 
 record {
   current_sale: opt SaleStatusStable;
   metadata: CandyShared;
 };
type NFTInfoResult = 
 variant {
   err: OrigynError;
   ok: NFTInfoStable;
 };
type NFTBackupChunk = 
 record {
   allocations: vec record {
                      record {
                        text;
                        text;
                      };
                      AllocationRecordStable;
                    };
   buckets: vec record {
                  principal;
                  StableBucketData;
                };
   canister: principal;
   collection_data: StableCollectionData;
   escrow_balances: StableEscrowBalances;
   nft_ledgers: StableNftLedger;
   nft_sales: vec record {
                    text;
                    SaleStatusStable;
                  };
   offers: StableOffers;
   sales_balances: StableSalesBalances;
 };
type MetricsGranularity = 
 variant {
   daily;
   hourly;
 };
type MarketTransferResult = 
 variant {
   err: OrigynError;
   ok: MarketTransferRequestReponse;
 };
type MarketTransferRequestReponse = 
 record {
   index: nat;
   timestamp: int;
   token_id: text;
   txn_type:
    variant {
      auction_bid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: text;
         token: TokenSpec;
       };
      burn: record {
              extensible: CandyShared;
              from: opt Account;
            };
      canister_managers_updated:
       record {
         extensible: CandyShared;
         managers: vec principal;
       };
      canister_network_updated:
       record {
         extensible: CandyShared;
         network: principal;
       };
      canister_owner_updated:
       record {
         extensible: CandyShared;
         owner: principal;
       };
      data:
       record {
         data_dapp: opt text;
         data_path: opt text;
         extensible: CandyShared;
         hash: opt vec nat8;
       };
      deposit_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         token: TokenSpec;
         trx_id: TransactionID;
       };
      escrow_deposit:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      escrow_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      extensible: CandyShared;
      mint:
       record {
         extensible: CandyShared;
         from: Account;
         sale: opt record {
                     amount: nat;
                     token: TokenSpec;
                   };
         to: Account;
       };
      owner_transfer:
       record {
         extensible: CandyShared;
         from: Account;
         to: Account;
       };
      royalty_paid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         receiver: Account;
         sale_id: opt text;
         seller: Account;
         tag: text;
         token: TokenSpec;
       };
      sale_ended:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: opt text;
         seller: Account;
         token: TokenSpec;
       };
      sale_opened:
       record {
         extensible: CandyShared;
         pricing: PricingConfig;
         sale_id: text;
       };
      sale_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
    };
 };
type MarketTransferRequest = 
 record {
   sales_config: SalesConfig;
   token_id: text;
 };
type ManageStorageResult = 
 variant {
   err: OrigynError;
   ok: ManageStorageResponse;
 };
type ManageStorageResponse = 
 variant {
   add_storage_canisters: record {
                            nat;
                            nat;
                          };
   configure_storage: record {
                        nat;
                        nat;
                      };
 };
type ManageStorageRequest = 
 variant {
   add_storage_canisters: vec record {
                                principal;
                                nat;
                                record {
                                  nat;
                                  nat;
                                  nat;
                                };
                              };
   configure_storage: variant {
                        heap: opt nat;
                        stableBtree: opt nat;
                      };
 };
type ManageSaleResult = 
 variant {
   err: OrigynError;
   ok: ManageSaleResponse;
 };
type ManageSaleResponse = 
 variant {
   bid: BidResponse;
   distribute_sale: DistributeSaleResponse;
   end_sale: EndSaleResponse;
   escrow_deposit: EscrowResponse;
   open_sale: bool;
   refresh_offers: vec EscrowRecord;
   withdraw: WithdrawResponse;
 };
type ManageSaleRequest = 
 variant {
   bid: BidRequest;
   distribute_sale: DistributeSaleRequest;
   end_sale: text;
   escrow_deposit: EscrowRequest;
   open_sale: text;
   refresh_offers: opt Account;
   withdraw: WithdrawRequest;
 };
type ManageCollectionCommand = 
 variant {
   UpdateAnnounceCanister: opt principal;
   UpdateLogo: opt text;
   UpdateManagers: vec principal;
   UpdateMetadata: record {
                     text;
                     opt CandyShared;
                     bool;
                   };
   UpdateName: opt text;
   UpdateNetwork: opt principal;
   UpdateOwner: principal;
   UpdateSymbol: opt text;
 };
type LogMessagesData = 
 record {
   caller: Caller;
   data: Data;
   message: text;
   timeNanos: Nanos;
 };
type ICTokenSpec = 
 record {
   canister: principal;
   decimals: nat;
   fee: opt nat;
   id: opt nat;
   standard: variant {
               DIP20;
               EXTFungible;
               ICRC1;
               Ledger;
               Other: CandyShared;
             };
   symbol: text;
 };
type HttpRequest = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type HourlyMetricsData = 
 record {
   canisterCycles: CanisterCyclesAggregatedData;
   canisterHeapMemorySize: CanisterHeapMemoryAggregatedData;
   canisterMemorySize: CanisterMemoryAggregatedData;
   timeMillis: int;
   updateCalls: UpdateCallsAggregatedData;
 };
type HistoryResult = 
 variant {
   err: OrigynError;
   ok: vec TransactionRecord;
 };
type HeaderField = 
 record {
   text;
   text;
 };
type HTTPResponse = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
 };
type GovernanceResult = 
 variant {
   err: OrigynError;
   ok: GovernanceResponse;
 };
type GovernanceResponse = 
 variant {
   clear_shared_wallets: bool;
   update_system_var: bool;
 };
type GovernanceRequest = 
 variant {
   clear_shared_wallets: text;
   update_system_var: record {
                        key: text;
                        token_id: text;
                        val: CandyShared;
                      };
 };
type GetMetricsParameters = 
 record {
   dateFromMillis: nat;
   dateToMillis: nat;
   granularity: MetricsGranularity;
 };
type GetLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   fromTimeNanos: opt Nanos;
 };
type GetLogMessagesFilter = 
 record {
   analyzeCount: nat32;
   messageContains: opt text;
   messageRegex: opt text;
 };
type GetLatestLogMessagesParameters = 
 record {
   count: nat32;
   filter: opt GetLogMessagesFilter;
   upToTimeNanos: opt Nanos;
 };
type GenericValue = 
 variant {
   BlobContent: vec nat8;
   BoolContent: bool;
   FloatContent: float64;
   Int16Content: int16;
   Int32Content: int32;
   Int64Content: int64;
   Int8Content: int8;
   IntContent: int;
   Nat16Content: nat16;
   Nat32Content: nat32;
   Nat64Content: nat64;
   Nat8Content: nat8;
   NatContent: nat;
   NestedContent: Vec;
   Principal: principal;
   TextContent: text;
 };
type EscrowResponse = 
 record {
   balance: nat;
   receipt: EscrowReceipt;
   transaction: TransactionRecord;
 };
type EscrowRequest = 
 record {
   deposit: DepositDetail;
   lock_to_date: opt int;
   token_id: text;
 };
type EscrowRecord = 
 record {
   account_hash: opt blob;
   amount: nat;
   buyer: Account;
   lock_to_date: opt int;
   sale_id: opt text;
   seller: Account;
   token: TokenSpec;
   token_id: text;
 };
type EscrowReceipt = 
 record {
   amount: nat;
   buyer: Account;
   seller: Account;
   token: TokenSpec;
   token_id: text;
 };
type Errors = 
 variant {
   app_id_not_found;
   asset_mismatch;
   attempt_to_stage_system_data;
   auction_ended;
   auction_not_started;
   bid_too_low;
   cannot_find_status_in_metadata;
   cannot_restage_minted_token;
   content_not_deserializable;
   content_not_found;
   deposit_burned;
   escrow_cannot_be_removed;
   escrow_owner_not_the_owner;
   escrow_withdraw_payment_failed;
   existing_sale_found;
   id_not_found_in_metadata;
   improper_interface;
   item_already_minted;
   item_not_owned;
   kyc_error;
   kyc_fail;
   library_not_found;
   malformed_metadata;
   no_escrow_found;
   not_enough_storage;
   nyi;
   out_of_range;
   owner_not_found;
   property_not_found;
   receipt_data_mismatch;
   sale_id_does_not_match;
   sale_not_found;
   sale_not_over;
   sales_withdraw_payment_failed;
   storage_configuration_error;
   token_id_mismatch;
   token_non_transferable;
   token_not_found;
   unauthorized_access;
   unreachable;
   update_class_error;
   validate_deposit_failed;
   validate_deposit_wrong_amount;
   validate_deposit_wrong_buyer;
   validate_trx_wrong_host;
   withdraw_too_large;
 };
type EndSaleResponse = 
 record {
   index: nat;
   timestamp: int;
   token_id: text;
   txn_type:
    variant {
      auction_bid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: text;
         token: TokenSpec;
       };
      burn: record {
              extensible: CandyShared;
              from: opt Account;
            };
      canister_managers_updated:
       record {
         extensible: CandyShared;
         managers: vec principal;
       };
      canister_network_updated:
       record {
         extensible: CandyShared;
         network: principal;
       };
      canister_owner_updated:
       record {
         extensible: CandyShared;
         owner: principal;
       };
      data:
       record {
         data_dapp: opt text;
         data_path: opt text;
         extensible: CandyShared;
         hash: opt vec nat8;
       };
      deposit_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         token: TokenSpec;
         trx_id: TransactionID;
       };
      escrow_deposit:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      escrow_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      extensible: CandyShared;
      mint:
       record {
         extensible: CandyShared;
         from: Account;
         sale: opt record {
                     amount: nat;
                     token: TokenSpec;
                   };
         to: Account;
       };
      owner_transfer:
       record {
         extensible: CandyShared;
         from: Account;
         to: Account;
       };
      royalty_paid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         receiver: Account;
         sale_id: opt text;
         seller: Account;
         tag: text;
         token: TokenSpec;
       };
      sale_ended:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: opt text;
         seller: Account;
         token: TokenSpec;
       };
      sale_opened:
       record {
         extensible: CandyShared;
         pricing: PricingConfig;
         sale_id: text;
       };
      sale_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
    };
 };
type EXTUser = 
 variant {
   address: text;
   "principal": principal;
 };
type EXTTransferResponse = 
 variant {
   err:
    variant {
      CannotNotify: EXTAccountIdentifier;
      InsufficientBalance;
      InvalidToken: EXTTokenIdentifier;
      Other: text;
      Rejected;
      Unauthorized: EXTAccountIdentifier;
    };
   ok: EXTBalance;
 };
type EXTTransferRequest = 
 record {
   amount: EXTBalance;
   from: EXTUser;
   memo: EXTMemo;
   notify: bool;
   subaccount: opt EXTSubAccount;
   to: EXTUser;
   token: EXTTokenIdentifier;
 };
type EXTTokensResult = 
 variant {
   err: EXTCommonError;
   ok: vec EXTTokensResponse;
 };
type EXTTokensResponse = 
 record {
   nat32;
   opt record {
         locked: opt int;
         price: nat64;
         seller: principal;
       };
   opt vec nat8;
 };
type EXTTokenIdentifier = text;
type EXTSubAccount = vec nat8;
type EXTMetadataResult = 
 variant {
   err: EXTCommonError;
   ok: EXTMetadata;
 };
type EXTMetadata = 
 variant {
   fungible:
    record {
      decimals: nat8;
      metadata: opt blob;
      name: text;
      symbol: text;
    };
   nonfungible: record {metadata: opt blob;};
 };
type EXTMemo = blob;
type EXTCommonError = 
 variant {
   InvalidToken: EXTTokenIdentifier;
   Other: text;
 };
type EXTBearerResult = 
 variant {
   err: EXTCommonError;
   ok: EXTAccountIdentifier;
 };
type EXTBalanceResult = 
 variant {
   err: EXTCommonError;
   ok: EXTBalance;
 };
type EXTBalanceRequest = 
 record {
   token: EXTTokenIdentifier;
   user: EXTUser;
 };
type EXTBalance = nat;
type EXTAccountIdentifier = text;
type DutchStateStable = 
 record {
   allow_list: opt vec record {
                         principal;
                         bool;
                       };
   config: PricingConfig;
   current_broker_id: opt principal;
   end_date: opt int;
   status: variant {
             closed;
             not_started;
             open;
           };
   winner: opt Account;
 };
type DutchConfig = 
 record {
   allow_list: opt vec principal;
   decay_per_hour: variant {
                     flat: nat;
                     percent: float64;
                   };
   reserve: opt nat;
   start_date: int;
   start_price: nat;
   token: TokenSpec;
 };
type DistributeSaleResponse = vec Result;
type DistributeSaleRequest = record {seller: opt Account;};
type DepositWithdrawDescription = 
 record {
   amount: nat;
   buyer: Account;
   token: TokenSpec;
   withdraw_to: Account;
 };
type DepositDetail = 
 record {
   amount: nat;
   buyer: Account;
   sale_id: opt text;
   seller: Account;
   token: TokenSpec;
   trx_id: opt TransactionID;
 };
type Data = 
 variant {
   Array: vec CandyShared;
   Blob: blob;
   Bool: bool;
   Bytes: vec nat8;
   Class: vec PropertyShared;
   Float: float64;
   Floats: vec float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Ints: vec int;
   Map: vec record {
              CandyShared;
              CandyShared;
            };
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Nats: vec nat;
   Option: opt CandyShared;
   Principal: principal;
   Set: vec CandyShared;
   Text: text;
 };
type DailyMetricsData = 
 record {
   canisterCycles: NumericEntity;
   canisterHeapMemorySize: NumericEntity;
   canisterMemorySize: NumericEntity;
   timeMillis: int;
   updateCalls: nat64;
 };
type DIP721TokensMetadata = 
 variant {
   Err: NftError;
   Ok: vec TokenMetadata;
 };
type DIP721TokensListMetadata = 
 variant {
   Err: NftError;
   Ok: vec nat;
 };
type DIP721TokenMetadata = 
 variant {
   Err: NftError;
   Ok: TokenMetadata;
 };
type DIP721SupportedInterface = 
 variant {
   Approval;
   Burn;
   Mint;
   TransactionHistory;
 };
type DIP721Stats = 
 record {
   cycles: nat;
   total_supply: nat;
   total_transactions: nat;
   total_unique_holders: nat;
 };
type DIP721NatResult = 
 variant {
   Err: NftError;
   Ok: nat;
 };
type DIP721Metadata = 
 record {
   created_at: nat64;
   custodians: vec principal;
   logo: opt text;
   name: opt text;
   symbol: opt text;
   upgraded_at: nat64;
 };
type DIP721BoolResult = 
 variant {
   Err: NftError;
   Ok: bool;
 };
type CollectionResult = 
 variant {
   err: OrigynError;
   ok: CollectionInfo;
 };
type CollectionInfo = 
 record {
   allocated_storage: opt nat;
   available_space: opt nat;
   created_at: opt nat64;
   fields: opt vec record {
                     text;
                     opt nat;
                     opt nat;
                   };
   logo: opt text;
   managers: opt vec principal;
   metadata: opt CandyShared;
   multi_canister: opt vec principal;
   multi_canister_count: opt nat;
   name: opt text;
   network: opt principal;
   owner: opt principal;
   symbol: opt text;
   token_ids: opt vec text;
   token_ids_count: opt nat;
   total_supply: opt nat;
   transaction_count: opt nat;
   unique_holders: opt nat;
   upgraded_at: opt nat64;
 };
type ChunkResult = 
 variant {
   err: OrigynError;
   ok: ChunkContent;
 };
type ChunkRequest = 
 record {
   chunk: opt nat;
   library_id: text;
   token_id: text;
 };
type ChunkContent = 
 variant {
   chunk:
    record {
      content: blob;
      current_chunk: opt nat;
      storage_allocation: AllocationRecordStable;
      total_chunks: nat;
    };
   remote: record {
             args: ChunkRequest;
             canister: principal;
           };
 };
type CanisterMetricsData = 
 variant {
   daily: vec DailyMetricsData;
   hourly: vec HourlyMetricsData;
 };
type CanisterMetrics = record {data: CanisterMetricsData;};
type CanisterMemoryAggregatedData = vec nat64;
type CanisterLogResponse = 
 variant {
   messages: CanisterLogMessages;
   messagesInfo: CanisterLogMessagesInfo;
 };
type CanisterLogRequest = 
 variant {
   getLatestMessages: GetLatestLogMessagesParameters;
   getMessages: GetLogMessagesParameters;
   getMessagesInfo;
 };
type CanisterLogMessagesInfo = 
 record {
   count: nat32;
   features: vec opt CanisterLogFeature;
   firstTimeNanos: opt Nanos;
   lastTimeNanos: opt Nanos;
 };
type CanisterLogMessages = 
 record {
   data: vec LogMessagesData;
   lastAnalyzedMessageTimeNanos: opt Nanos;
 };
type CanisterLogFeature = 
 variant {
   filterMessageByContains;
   filterMessageByRegex;
 };
type CanisterHeapMemoryAggregatedData = vec nat64;
type CanisterCyclesAggregatedData = vec nat64;
type CandyShared = 
 variant {
   Array: vec CandyShared;
   Blob: blob;
   Bool: bool;
   Bytes: vec nat8;
   Class: vec PropertyShared;
   Float: float64;
   Floats: vec float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Ints: vec int;
   Map: vec record {
              CandyShared;
              CandyShared;
            };
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Nats: vec nat;
   Option: opt CandyShared;
   Principal: principal;
   Set: vec CandyShared;
   Text: text;
 };
type Caller = opt principal;
type BidResponse = 
 record {
   index: nat;
   timestamp: int;
   token_id: text;
   txn_type:
    variant {
      auction_bid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: text;
         token: TokenSpec;
       };
      burn: record {
              extensible: CandyShared;
              from: opt Account;
            };
      canister_managers_updated:
       record {
         extensible: CandyShared;
         managers: vec principal;
       };
      canister_network_updated:
       record {
         extensible: CandyShared;
         network: principal;
       };
      canister_owner_updated:
       record {
         extensible: CandyShared;
         owner: principal;
       };
      data:
       record {
         data_dapp: opt text;
         data_path: opt text;
         extensible: CandyShared;
         hash: opt vec nat8;
       };
      deposit_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         token: TokenSpec;
         trx_id: TransactionID;
       };
      escrow_deposit:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      escrow_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
      extensible: CandyShared;
      mint:
       record {
         extensible: CandyShared;
         from: Account;
         sale: opt record {
                     amount: nat;
                     token: TokenSpec;
                   };
         to: Account;
       };
      owner_transfer:
       record {
         extensible: CandyShared;
         from: Account;
         to: Account;
       };
      royalty_paid:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         receiver: Account;
         sale_id: opt text;
         seller: Account;
         tag: text;
         token: TokenSpec;
       };
      sale_ended:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         sale_id: opt text;
         seller: Account;
         token: TokenSpec;
       };
      sale_opened:
       record {
         extensible: CandyShared;
         pricing: PricingConfig;
         sale_id: text;
       };
      sale_withdraw:
       record {
         amount: nat;
         buyer: Account;
         extensible: CandyShared;
         fee: nat;
         seller: Account;
         token: TokenSpec;
         token_id: text;
         trx_id: TransactionID;
       };
    };
 };
type BidRequest = 
 record {
   broker_id: opt principal;
   escrow_receipt: EscrowReceipt;
   sale_id: text;
 };
type BearerResult = 
 variant {
   err: OrigynError;
   ok: Account;
 };
type BalanceResult = 
 variant {
   err: OrigynError;
   ok: BalanceResponse;
 };
type BalanceResponse = 
 record {
   escrow: vec EscrowRecord;
   multi_canister: opt vec principal;
   nfts: vec text;
   offers: vec EscrowRecord;
   sales: vec EscrowRecord;
   stake: vec StakeRecord;
 };
type AuctionStateStable = 
 record {
   allow_list: opt vec record {
                         principal;
                         bool;
                       };
   config: PricingConfig;
   current_bid_amount: nat;
   current_broker_id: opt principal;
   current_escrow: opt EscrowReceipt;
   end_date: int;
   min_next_bid: nat;
   participants: vec record {
                       principal;
                       int;
                     };
   status: variant {
             closed;
             not_started;
             open;
           };
   wait_for_quiet_count: opt nat;
   winner: opt Account;
 };
type AuctionConfig = 
 record {
   allow_list: opt vec principal;
   buy_now: opt nat;
   ending:
    variant {
      date: int;
      waitForQuiet:
       record {
         date: int;
         extention: nat64;
         fade: float64;
         max: nat;
       };
    };
   min_increase: variant {
                   amount: nat;
                   percentage: float64;
                 };
   reserve: opt nat;
   start_date: int;
   start_price: nat;
   token: TokenSpec;
 };
type AllocationRecordStable = 
 record {
   allocated_space: nat;
   available_space: nat;
   canister: principal;
   chunks: vec nat;
   library_id: text;
   token_id: text;
 };
type Account = 
 variant {
   account: record {
              owner: principal;
              sub_account: opt blob;
            };
   account_id: text;
   extensible: CandyShared;
   "principal": principal;
 };
/// The entry point for an ORIGYN NFT actor
service : () -> Nft_Canister
